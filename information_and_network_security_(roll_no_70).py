# -*- coding: utf-8 -*-
"""Information And Network Security (Roll No. :- 70).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EUKvIWgKIy8r11oXO8J6yNXH63bBks6T

> # **Practical No. 1**
>  
> #### IMPLEMENTING SUBSTITUTION CIPHER
> ---

### **A] CEASER CIPHER**

**Encryption**
"""

def caesar_encrypt(word):
    c = ''
    for i in word:
        if (i == ' '):
            c += ' '
        else:
            c += (chr(ord(i) + 3))
    return c


word = "Hello world"
encrypted = caesar_encrypt(word)
print(encrypted)

"""**Decryption**"""

def caesar_decrypt(word):
    c = ''
    for i in word:
        if (i == ' '):
            c += ' '
        else:
            c += (chr(ord(i) - 3))
    return c

caesar_decrypt(encrypted)

"""### **B] MODIFIED CEASER CIPHER**

**Encryption**
"""

def modified_caesar_encrypt(word, k):
    c = ''
    for i in word:
        if (i == ' '):
            c += ' '
        else:
            c += (chr(ord(i) + k))
    return c

word = "strawberry cheesecake"
k = 3
encrypted = modified_caesar_encrypt(word, k)

"""**Decryption**"""

def modified_caesar_decrypt(word, k):
    c = ''
    for i in word:
        if (i == ' '):
            c += ' '
        else:
            c += (chr(ord(i) - k))
    return c

modified_caesar_decrypt(encrypted, k)

"""### **C] MONO-ALPHABETIC**

**Utility Dictionaries**
"""

key_dict = {'a': 'm','b': 'n','c': 'b','d': 'v','e': 'c','f': 'x','g': 'z','h': 'a','i': 's','j': 'd','k': 'f','l': 'g','m': 'h','n': 'j','o': 'k','p': 'l','q': 'p','r': 'o','s': 'i','t': 'u','u': 'y','v': 't','w': 'r','x': 'e','y': 'w','z': 'q',' ': ' ',}

"""**Get key for Decryption**"""

def get_key(value):
    for key, val in key_dict.items():
        if (val == value):
            return key

"""**Encryption**"""

def monoalphabetic_encrypt():
    word = input("Enter the plain text: ")
    c = ''
    for i in word:
        i = key_dict[i]
        c += i
    return c
monoalphabetic_encrypt()

"""**Decryption**"""

def monoalphabetic_decrypt():
    word = input("Enter the cipher text: ")
    c = ''
    for i in word:
        i = get_key(i)
        c += i
    return c
  
monoalphabetic_decrypt()

"""### **D] POLY-ALPHABETIC**

> # **Practical No. 2**
>  
> #### IMPLEMENTING TRANSPOSITION CIPHER
> ---

### **A] RAILFENCE TRANSPOSITION CIPHER**

**Encryption**
"""

def rail_fence_encrypt():
    word = list(input("Enter the plain text: "))
    even, odd  = [word[i] for i in range(0, len(word), 2)], [word[i] for i in range(1, len(word), 2)]
    return ''.join(even) + ''.join(odd)
  
rail_fence_encrypt()

"""**Decryption**"""

def rail_fence_decrypt():
    word = list(input("Enter the plain text: "))
    if(len(word) % 2 == 0):
        odd, even = word[: int(len(word) / 2)], word[int(len(word) / 2): ]
    else:
        odd, even = word[: int(len(word) / 2) + 1], word[int(len(word) / 2) + 1:]
    if (len(odd) != len(even)):
        even.append(' ')
    plain = [odd[i] + even[i] for i in range(len(odd))]
    return ''.join(plain)

rail_fence_decrypt()

"""Railfence 2.0"""

''' Encryption '''
def railfence_encrypt(message, rails):
    tracks = {"R" + str(i) : [" " for _ in range(len(message))] for i in range(rails)}
    r = 0; direction = 1; t = 0

    for char in message:
        #print(r, direction)
        tracks["R" + str(r)][t] = char
        t += 1
        r += direction
        if r <= 0 or r >= rails - 1:
            direction = direction * (-1)
    
    cipher = ""
    for t in range(rails):
        for k in tracks["R" + str(t)]:
            if k != " ":
                cipher += k

    for i in tracks:
        for k in tracks[i]:
            print(k, end = " ")
        print()

    return cipher

    ''' Decryption '''
def railfence_decrypt(encrypted, rails):
    tracks = {"R" + str(i) : [" " for _ in range(len(encrypted))] for i in range(rails)}
    r = 0; direction = 1; t = 0

    for char in encrypted:
        tracks["R" + str(r)][t] = '*'

        t += 1
        r += direction
        if r <= 0 or r >= rails - 1:
            direction = direction * (-1)

    index = 0
    for r in range(rails): 
        for t in range(len(encrypted)): 
            if index < len(encrypted):
                if tracks["R" + str(r)][t] == '*': 
                    tracks["R" + str(r)][t] = encrypted[index] 
                    index += 1

    result = "" 
    r, direction, t = 0, 1, 0 
    for i in range(len(encrypted)): 
              
        if tracks["R" + str(r)][t] != "*": 
            result += tracks["R" + str(r)][t]
            t += 1
              
        r += direction
        if r <= 0 or r >= rails - 1:
            direction = direction * (-1)

    return(result)

message = "redvelvetcheesecake"
rails = 4
encrypted = railfence_encrypt(message, rails)
decrypted = railfence_decrypt(encrypted, rails)

print("\nOriginal:\t", message)
print("Encrypted:\t", encrypted)
print("Decrypted:\t", decrypted)

"""### **B] SIMPLE COLUMNAR**

**Encryption**
"""

def simple_columnar_encrypt(message, key):
    columns = {i:[] for i in key}; col = 0
    for i in message:
        columns[key[col]].append(i)
        col = (col + 1) % len(key)
 
    for c in columns:
        print(c, ":", columns[c])
 
    order = sorted([i for i in key])
    result = ""
    for o in order:
        result += "".join([i for i in columns[o]])
 
    return result
 
 
def simple_columnar_decrypt(encrypted, key):
    mixed_order = sorted(key)
    n = len(encrypted) // len(key)
 
    columns = {i:[] for i in sorted(key)};
    col = 0
 
    for i in encrypted:
        char = mixed_order[col]
        columns[char].append(i)        
        if len(columns[char]) >= n:
            col += 1
 
    result = ""; t = 0; x = 0
    while x < len(encrypted) - 2:
        for k in key:
            result += columns[k][t]
            #print(result)
            x += 1
        t += 1
 
    return result

message = "SIMPLECOLUMNAR"
key = "HACK"
 
message += (len(message) % len(key)) * " "
encrypted = simple_columnar_encrypt(message, key)
decrypted = simple_columnar_decrypt(encrypted, key)
 
print("\nOriginal:\t", message)
print("Encrypted:\t", encrypted)
print("Decrypted:\t", decrypted)

"""### **C] VERNAM CIPHER**"""

vernam_dict = dict((i, chr(i + 96)) for i in range(1, 27))

"""**Encryption**"""

def vernam(plain, key):
    plain = plain.lower()
    ckey = ''.join([(key[i % len(key)]) for i in range(len(list(plain)))])
    cipher = ''
    for i in range(len(plain)):
        if plain[i] == ' ':
            cipher += ' '
        else:
            cipher += vernam_dict[(ord(plain[i]) + ord(ckey[i])) % 26]
    print("Plain:\t\t", plain, "\nEncrypted:\t", cipher)

vernam('Cheese and Pepperoni', 'hello')

# Initializing variables required
charmap = {}

def vernamEncryption(plaintext, key):
    # Initializing ciphertext
    ciphertext = ''
    print(charmap)
    for i in range(len(plaintext)):
        p = plaintext[i]
        k = key[i]
        # Performing vernam encryption step
        sum = charmap[p] + charmap[k]
        # Subtracting 26 if sum overflows above values
        if sum >= 26:
            sum -= 26
        # Adding to ciphertext
        ciphertext += chr(sum + 65)

    # Returning ciphertext
    return ciphertext

def vernamDecryption(ciphertext, key):
    # Initializing plaintext
    plaintext = ''
    for i in range(len(ciphertext)):
        c = ciphertext[i]
        keyLetter = key[i]
        # Performing vernam decryption step
        diff = charmap[c] - charmap[keyLetter]
        # Adding 26 if diff underflows above values
        if diff < 0:
            diff += 26
        # Adding to plaintext
        plaintext += chr(diff + 65)

    # Returning" plaintext
    return plaintext

# Taking inputs from the user
plaintext = "pepperoniandcheese"
key = "pizza"

# Initializing alphabets for rotating
alphabets = "abcdefghijklmnopqrstuvwxyz ".upper()
# Initializing values to alphabets
for alphabet in alphabets:
    charmap[alphabet] = ord(alphabet) - 65

plaintext = plaintext.upper()
key = key.upper()

# Checking if key is invalid
if len(key) < len(plaintext):
    z = (len(plaintext) - len(key)) // len(key)
    y = len(plaintext) - len(key) - (z * len(key))
    key += key * z + key[:y]

# Encryption
ciphertext = vernamEncryption(plaintext, key)

# Decryption
plaintext = vernamDecryption(ciphertext, key)

# Printing answers
print("Plaintext:\t", plaintext)
print("Key:\t\t", key)
print("Encrypted:\t", ciphertext)
print("Decrypted:\t", plaintext)
print()

"""> # **Practical No. 3**
> ---

### **A] IMPLEMENTING DIFFIE-HELLMAN KEY EXCHANGE ALGORITHM**
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install pyDH

import pyDH
d1 = pyDH.DiffieHellman()
d2 = pyDH.DiffieHellman()
d1_pubkey = d1.gen_public_key()
d2_pubkey = d2.gen_public_key()
d1_sharedkey = d1.gen_shared_key(d2_pubkey)
d2_sharedkey = d2.gen_shared_key(d1_pubkey)

print(d1_sharedkey == d2_sharedkey)

print(d1_pubkey,'\n',d2_pubkey)
print(d1_sharedkey,' and ',d2_sharedkey)

"""### **B] DIFFIE-HELLMAN KEY EXCHANCE ALGORITHM**"""

from random import randint
 
# Both the persons will be agreed upon the 
# public keys G and P 
# A prime number P is taken 
P = 23
  
# A primitve root for P, G is taken
G = 9
print('The Value of P is :%d'%(P))
print('The Value of G is :%d'%(G))
  
# Alice will choose the private key a 
a = 4
print('The Private Key a for Alice is :%d'%(a))
  
# gets the generated key
x = int(pow(G,a,P))  
  
# Bob will choose the private key b
b = 3
print('The Private Key b for Bob is :%d'%(b))

# gets the generated key
y = int(pow(G,b,P))    
# Secret key for Alice 
ka = int(pow(y,a,P))
# Secret key for Bob 
kb = int(pow(x,b,P))
  
print('Secret key for the Alice is : %d'%(ka))
print('Secret Key for the Bob is : %d'%(kb))

"""> # **Practical No. 4**
> ---
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install Crypto

"""### **A] IMPLEMENTING DES ALGORITHM**"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install pyCrypto

from Crypto.Cipher import DES
from Crypto import Random
iv = Random.get_random_bytes(8)
des1 = DES.new('01234567', DES.MODE_CFB, iv)
des2 = DES.new('01234567', DES.MODE_CFB, iv)
text = 'Sanwich'
cipher_text = des1.encrypt(text)
print("Encrpted message ",cipher_text) 
print("Decrypted Original Message: ",(des2.decrypt(cipher_text)))

"""### **B] IMPLEMENTING AES**"""

from Crypto.Cipher import AES 
import binascii,os
import random, string

iv = os.urandom(16)
aes_mode = AES.MODE_CBC
key = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
print(key)
encryptor = AES.new(key, aes_mode, iv)
def aes_encrypt(plaintext):
    plaintext = convert_to_16(plaintext)

    ciphertext = encryptor.encrypt(plaintext)
    return ciphertext


def convert_to_16(plaintext):
    add = 16 - (len(plaintext) % 16)
    return(plaintext + ' ' * add)


Encrypted = aes_encrypt('Jaisal ')
print("Encrypted message :",Encrypted)

decryptor = AES.new(key, aes_mode, iv)
plaintext = decryptor.decrypt(Encrypted)
print(plaintext.decode('utf-8'))

"""> # **Practical No. 5**
> ---

### **IMPLEMENTING RSA ALGORITHM**
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install pyCrypto

#Initializing RSA
#Generating Private and Public key

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import binascii

keyPair = RSA.generate(3072)

pubKey = keyPair.publickey()
print(f"Public key: (n={hex(pubKey.n)}, e={hex(pubKey.e)})")
pubKeyPEM = pubKey.exportKey()
print(pubKeyPEM.decode('ascii'))

print(f"Private key: (n={hex(pubKey.n)}, d={hex(keyPair.d)})")
privKeyPEM = keyPair.exportKey()
print(privKeyPEM.decode('ascii'))

"""**Encryption**"""

msg = bytes(str(input("Enter plain text: ")), 'utf-8')
encryptor = PKCS1_OAEP.new(pubKey)
encrypted = encryptor.encrypt(msg)
print("Encrypted:", binascii.hexlify(encrypted))

"""**Decryption**"""

decryptor = PKCS1_OAEP.new(keyPair)
decrypted = decryptor.decrypt(encrypted)
print('Decrypted:', decrypted.decode('utf-8'))

"""> # **Practical No. 6**
> ---

### **MESSAGE DIGEST**

> # **Practical No. 7**
> ---

### **HASH FUNCTION**

> # **Practical No. 8**

### **A] ASSYMETRIC KEY ALGORITHM FOR Generate PUBLIC PRIVATE KEY**

### **B] SYMMETRIC KEY FOR GENERATE CIPHER ALGO SYMMETRIC**

> # **Practical No. 9**

### **GENERATING PASS PHRASE FOR ENCRYPTION**
"""